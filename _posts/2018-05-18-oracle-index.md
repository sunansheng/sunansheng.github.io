---
layout: post
title: Oracle 索引详解
categories: [Oracle]
tags: 索引
---

>设想一下，在大型的商业数据库中有一个包含数百万条记录的表，如果该表没有索引，那么查询其中的任何记录就只能通过顺序地扫描该表中的每一行记录来完成。这会产生大量的磁盘输入/输出(I/O)，因此也就会大大地降低系统的效率。

引入索引的目的就是为了加快查询的速度。Oracle索引是一个独立于表的对象，它可以存放在与表不同的表空间中。即使索引崩溃，甚至索引被删除都不会影响真正存有数据的表。在Oracle数据库中，一个索引一旦被建立就由Oracle系统自动维护，而且由Oracle系统决定什么时候使用该索引，不用在查询语句中指定使用哪个索引。使用的查询语句与未建索引时几乎完全一样，只是查询速度快多了。虽然Oracle索引是一个独立于表的对象，但是当一个表被删除时所有基于该表的索引都会被自动地删除。

## 1. 索引的分类

索引可以按逻辑设计分类，也可以以按物理实现分类。索引的逻辑分类是从应用的角度来划分，而物理分类是从其物理存储的角度来划分。

### 1.1 逻辑分类

- 单列索引：基于一列的索引，如在emp表中的ename列上的索引。

- 多列索引：也叫组合(复合)索引，是基于多列的索引，如在emp表中的job和sal两列上所创建的索引。组合索引中的列数最多为32列。

- 唯一索引：保证表中任何数据行的索引列的值都不相同。

- 基于函数的索引：利用表中的一列或多列使用函数或表达式所创建的索引。基于函数的索引预先计算函数或表达式的值并存储在该索引中。基于函数的索引既可以是B-树索引，也可以是位图索引。

### 1.2 物理分类

- 分区或非分区索引

- B-树

- 位图索引

## 3. B-树索引


Oracle通过索引机制来加速数据的存取。Oracle的B树索引(B-Tree索引)以树型结构来存放键值(key value)。每个B树索引都有一个根节点(root)，对索引进行访问时首先从根节点开始，根据和根节点上键值的比较结果，找到相应的分支节点(branch)，再和分支节点的键值进行比较，最后一直找到叶子(leaf)节点。在叶子节点上，存放索引的键值和表中对应这个键值的记录的物理地址(rowid)。通过rowid，就可以直接定位到表的记录。

![](/images/posts/20180622134027.jpg)

对于惟一索引，一个键值和一条记录的rowid相对应，对于非惟一索引，一个键值可能对应多条记录的rowid。B树索引对于具有惟一键值或者键值很少重复的情况，具有很高的存取效率。但是对于那些键值大量重复的列，B树索引并不适用，因为即使找到对应的键值仍然要扫描大量的rowid，这种情况下使用B树索引已经没有什么意义了。

> 所有索引所在列的值为空(null)的数据行，Oracle将不存储与之对应的索引项。因此，如果在WHERE子句中索引所在列的值为null，则**Oracle将不使用索引而进行全表扫描**。

## 4. 位图索引

Oracle针对这种情况提供了Bitmap索引。Bitmap索引适用于键值大量重复的列的查询。Bitmap索引对索引列的每一个键值分别索引。对于一个键值，可能分成一到多个范围进行存储。每个键值的存储范围大致包括以下几个部分。首先是索引的键值，接着存放当前范围的起始rowid和终止rowid，最后是这个键值在这个范围内的位置编码。将这个十六进制编码转化为二进制后，编码值是1的代表记录符合索引的键值，是0则表示不符合。由于保存了起始和终止的rowid以及在这个范围内的位置变化，因此通过转换，Bitmap索引也可以对应到rowid。所以，Bitmap索引可以提供和B-Tree索引相同的功能。